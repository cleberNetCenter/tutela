const fs = require('fs');
const path = require('path');

function walk(dir, files = []) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      walk(full, files);
    } else {
      files.push(full);
    }
  }
  return files;
}

function toPosix(p) {
  return p.split(path.sep).join('/');
}

function shouldIgnore(relPath, ignore = []) {
  return ignore.some((pattern) => {
    if (pattern === '**/en/**') return relPath.includes('/en/');
    if (pattern === '**/es/**') return relPath.includes('/es/');
    if (pattern === '**/test*.html') {
      const base = path.basename(relPath);
      return /^test.*\.html$/i.test(base);
    }
    return false;
  });
}

function sync(pattern, options = {}) {
  const cwd = options.cwd ? path.resolve(options.cwd) : process.cwd();
  const ignore = options.ignore || [];
  const allFiles = walk(cwd);

  if (pattern === 'public/**/*.html') {
    return allFiles
      .map((f) => path.relative(cwd, f))
      .map(toPosix)
      .filter((f) => f.startsWith('public/') && f.endsWith('.html'))
      .filter((f) => !shouldIgnore(f, ignore));
  }

  return [];
}

module.exports = { sync };
